{
  function joinClauses(type, first, rest) {
    if (first.type === 'fact' && rest.length === 1 && (rest[0].type === 'conjunction' || rest[0].type === 'disjunction')) {
      rest[0].clauses.unshift(first);
      return rest[0];
    }
    return {
      type: type,
      clauses: [first].concat(rest),
    };
  }
  function comparisonTree(left, rest) {
    const right = rest.shift();
    const node = { type: 'comparison', left, operator: right.operator, right: right.expr };
    if (rest.length === 0) {
      return node;
    }
    return comparisonTree(node, rest);
  }
  function flatten(arr) {
    return arr.reduce((acc, cur) => acc.concat(Array.isArray(cur) ? flatten(cur) : cur), []);
  };
  function parseNumber(n) {
    return parseFloat(flatten(n).filter(d => d).join(''));
  }
}

statements
  = statement+

statement
  = comment:comment "\n"? { return comment }
  / inference:inference "." { return inference }
  / claim:claim "." { return claim }
  / fact:fact "." { return fact }
  / roll:rolling "." { return roll}
  / "?" query:clause "." { return { type: 'query', clause: query } }
  / [ \t\r\n]+ { return null }

fact
  = whitespace name:variable "(" args:arguments ")" whitespace { return { type: 'fact', table: name.value, fields: args.arguments } }
  / whitespace "~" fact:fact { return { ...fact, negative: true } }

expr
  = addition
  / multiplication 
  / probability
  / function
  / "(" comparison ")"
  / variable
  / roll
  / string 
  / number

term
  = multiplication
  / factor

factor
  = parenthetical_expr
  / function
  / variable
  / number 

addition
  = left:term whitespace operator:([+\-]) whitespace right:expr { return { type: 'binary_operation', operator, left, right } }

multiplication
  = left:factor whitespace operator:([*/]) whitespace right:expr { return { type: 'binary_operation', operator, left, right } }

parenthetical_expr
  = "(" " "* expr:expr " "* ")" { return expr }

function
  = name:variable "(" args:arguments ")" { return { type: 'function', function: name.value, arguments: args.arguments } }

arguments
  = whitespace first:expr rest:nextargs* whitespace { return { type: 'arguments', arguments: [first].concat(rest) } }

nextargs
  = "," whitespace expr:expr { return expr }

probability
  = "Pr(" whitespace left:expr whitespace operator:comparison_operator whitespace right:expr whitespace ")" { return { type: 'function', function: 'probability', arguments: [{ type: 'comparison', left, operator, right }] } }
  / "Pr(" whitespace arg:expr whitespace ")" { return { type: 'function', function: 'probability', arguments: [arg]}}

inference
  = left:fact ":-" whitespace right:clause { return { type: 'inference', left, right } }

clause
  = conjunction
  / disjunction
  / "(" whitespace clause:clause whitespace ")" { return clause }
  / comparison
  / fact

conjunction
  = "(" first:clause ")" whitespace rest:next_conjunction+ { return joinClauses('conjunction', first, rest) }
  / first:fact rest:next_conjunction+ { return joinClauses('conjunction', first, rest) }

disjunction
  = "(" first:fact ")" whitespace rest:next_disjunction+ { return joinClauses('disjunction', first, rest) }
  / first:fact rest:next_disjunction+ { return joinClauses('disjunction', first, rest) }

next_conjunction
  = "&" whitespace clause:clause { return clause }

next_disjunction
  = "|" whitespace clause:clause { return clause }

claim
  = "âˆ´" clause:clause { return { type: 'claim', clause: clause } }

rolling
  = "ğŸ²" clause:clause { return { type: 'rolling', clause: clause } }

comparison
  = whitespace "(" left:expr ")" rest:next_comparison+ { return comparisonTree(left, rest) }
  / whitespace left:expr rest:next_comparison+ { return comparisonTree(left, rest) }

next_comparison
  = whitespace operator:comparison_operator whitespace expr:expr { return { operator, expr } }

comparison_operator
  = op:"=" { return op }
  / op:"!=" { return op }
  / op:">=" { return op }
  / op:"<=" { return op }
  / op:">" { return op }
  / op:"<" { return op }

comment
  = "//" comment:[^\n]* { return { type: 'comment', value: comment.join('').trim() } }
  / "/*" comment:(!"*/" .)* "*/" { return { type: 'comment', value: comment.flat().join('').trim() }}

string
  = name:([A-Z][A-Za-z_]+) { return { type: 'string', value: name[0] + name[1].join('') } }

variable
  = name:([a-z_]+) { return { type: 'variable', value: name.join('') } }
  / "?" { return { type: 'variable', value: '?' } }

roll
  = count:([0-9]+) "d" die:([0-9]+) modifier:([+-][0-9]+)? { return { type: 'roll', count: parseInt(count.join('')), die: parseInt(die.join('')), modifier: modifier ? parseInt(modifier.join('')) : 0 } }

number
  = number:([-]?[0-9]+([.][0-9]+)?) { return { type: 'number', value: parseNumber(number) } }

whitespace
  = [ \t\r\n]*
